// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Hyperpolymath

//! HTTP client generation with pluggable HTTP backend

use crate::ir::{ApiSpec, Endpoint, HttpMethod, Parameter, ParameterLocation, RsType};
use super::Config;
use anyhow::Result;
use heck::ToPascalCase;

pub fn generate(spec: &ApiSpec, config: &Config) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str("// SPDX-License-Identifier: AGPL-3.0-or-later\n");
    output.push_str("// Generated by rescript-openapi - DO NOT EDIT\n");
    output.push_str(&format!("// Source: {} v{}\n\n", spec.title, spec.version));

    // Import types and schemas
    output.push_str(&format!("open {}Types\n", config.module_prefix));
    output.push_str(&format!("open {}Schema\n\n", config.module_prefix));

    // HTTP abstraction layer
    output.push_str(r#"/** API error type */
type apiError = {
  status: int,
  message: string,
  body: option<JSON.t>,
}

/** HTTP method */
type httpMethod = GET | POST | PUT | PATCH | DELETE | HEAD | OPTIONS

let methodToString = m => switch m {
| GET => "GET"
| POST => "POST"
| PUT => "PUT"
| PATCH => "PATCH"
| DELETE => "DELETE"
| HEAD => "HEAD"
| OPTIONS => "OPTIONS"
}

/** HTTP request configuration */
type httpRequest = {
  method: httpMethod,
  url: string,
  headers: Dict.t<string>,
  body: option<JSON.t>,
}

/** HTTP client module signature - implement this to use any HTTP library */
module type HttpClient = {
  let request: httpRequest => promise<result<JSON.t, apiError>>
}

/** Default fetch-based HTTP client */
module FetchClient: HttpClient = {
  let request = async (req: httpRequest): promise<result<JSON.t, apiError>> => {
    let headers = Fetch.Headers.fromObject(req.headers->Obj.magic)

    let init: Fetch.requestInit = {
      method: req.method->methodToString->Fetch.Method.make,
      headers,
      body: switch req.body {
      | Some(b) => Some(b->JSON.stringify->Fetch.Body.string)
      | None => None
      },
    }

    try {
      let response = await Fetch.fetch(req.url, init)

      if response->Fetch.Response.ok {
        let json = await response->Fetch.Response.json
        Ok(json)
      } else {
        let status = response->Fetch.Response.status
        let message = response->Fetch.Response.statusText
        let body = try {
          Some(await response->Fetch.Response.json)
        } catch {
        | _ => None
        }
        Error({status, message, body})
      }
    } catch {
    | Exn.Error(e) => Error({
        status: 0,
        message: Exn.message(e)->Option.getOr("Network error"),
        body: None
      })
    }
  }
}

/** Client configuration */
type config = {
  baseUrl: string,
  headers: Dict.t<string>,
}

let makeConfig = (~baseUrl: string, ~headers=Dict.make(), ()): config => {
  baseUrl,
  headers,
}

/** Build URL with query parameters */
let buildUrl = (baseUrl: string, path: string, query: Dict.t<string>): string => {
  let url = baseUrl ++ path
  let params = query
    ->Dict.toArray
    ->Array.map(((k, v)) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    ->Array.join("&")

  if params->String.length > 0 {
    url ++ "?" ++ params
  } else {
    url
  }
}

/** API client functor - provide your own HttpClient implementation */
module Make = (Http: HttpClient) => {
"#);

    // Generate endpoint functions inside the functor
    for endpoint in &spec.endpoints {
        output.push_str(&generate_endpoint(endpoint, config));
        output.push('\n');
    }

    output.push_str("}\n\n");

    // Default client using FetchClient
    output.push_str("/** Default client using fetch */\n");
    output.push_str("module Client = Make(FetchClient)\n\n");

    // Generate aliases map (operationId -> path-based name)
    output.push_str("/** Operation aliases for convenience */\n");
    output.push_str("module Aliases = {\n");
    for endpoint in &spec.endpoints {
        let alias = generate_path_alias(&endpoint.path, &endpoint.method);
        if alias != endpoint.operation_id {
            output.push_str(&format!("  let {} = Client.{}\n", alias, endpoint.operation_id));
        }
    }
    output.push_str("}\n");

    Ok(output)
}

fn generate_endpoint(endpoint: &Endpoint, _config: &Config) -> String {
    let mut output = String::new();

    // Documentation
    if let Some(doc) = &endpoint.doc {
        output.push_str(&format!("  /** {} */\n", doc));
    }

    let fn_name = &endpoint.operation_id;

    // Collect parameters by location
    let path_params: Vec<_> = endpoint.parameters.iter()
        .filter(|p| matches!(p.location, ParameterLocation::Path))
        .collect();
    let query_params: Vec<_> = endpoint.parameters.iter()
        .filter(|p| matches!(p.location, ParameterLocation::Query))
        .collect();
    let header_params: Vec<_> = endpoint.parameters.iter()
        .filter(|p| matches!(p.location, ParameterLocation::Header))
        .collect();

    // Build parameter list
    let mut params = vec!["config: config".to_string()];

    for p in &path_params {
        params.push(format!("~{}: {}", p.name, p.ty.to_rescript()));
    }

    if let Some(body) = &endpoint.request_body {
        params.push(format!("~body: {}", body.ty.to_rescript()));
    }

    // Optional query parameters
    for p in &query_params {
        if p.required {
            params.push(format!("~{}: {}", p.name, p.ty.to_rescript()));
        } else {
            params.push(format!("~{}=?", p.name));
        }
    }

    // Optional header parameters
    for p in &header_params {
        if p.required {
            params.push(format!("~{}: {}", p.name, p.ty.to_rescript()));
        } else {
            params.push(format!("~{}=?", p.name));
        }
    }

    // Determine return type
    let success_response = endpoint.responses.iter()
        .find(|r| r.status >= 200 && r.status < 300);

    let return_type = success_response
        .and_then(|r| r.ty.as_ref())
        .map(|t| t.to_rescript())
        .unwrap_or_else(|| "unit".to_string());

    output.push_str(&format!(
        "  let {} = async ({}, ()): promise<result<{}, apiError>> => {{\n",
        fn_name,
        params.join(", "),
        return_type
    ));

    // Build path with interpolation
    let path = build_path(&endpoint.path, &path_params);
    output.push_str(&format!("    let path = {}\n", path));

    // Build query dict
    output.push_str("    let query = Dict.make()\n");
    for p in &query_params {
        if p.required {
            output.push_str(&format!(
                "    query->Dict.set(\"{}\", {}->String.make)\n",
                p.name, p.name
            ));
        } else {
            output.push_str(&format!(
                "    switch {} {{ | Some(v) => query->Dict.set(\"{}\", v->String.make) | None => () }}\n",
                p.name, p.name
            ));
        }
    }

    // Build headers dict
    output.push_str("    let headers = Dict.fromArray(config.headers->Dict.toArray)\n");
    output.push_str("    headers->Dict.set(\"Content-Type\", \"application/json\")\n");

    for p in &header_params {
        if p.required {
            output.push_str(&format!(
                "    headers->Dict.set(\"{}\", {})\n",
                p.name, p.name
            ));
        } else {
            output.push_str(&format!(
                "    switch {} {{ | Some(v) => headers->Dict.set(\"{}\", v) | None => () }}\n",
                p.name, p.name
            ));
        }
    }

    // Build request body
    let body_expr = if let Some(body) = &endpoint.request_body {
        match &body.ty {
            RsType::Named(type_name) => {
                format!("Some(serialize{}(body))", type_name)
            }
            _ => "Some(body->Obj.magic)".to_string()
        }
    } else {
        "None".to_string()
    };

    // Make request
    let method = match endpoint.method {
        HttpMethod::Get => "GET",
        HttpMethod::Post => "POST",
        HttpMethod::Put => "PUT",
        HttpMethod::Patch => "PATCH",
        HttpMethod::Delete => "DELETE",
        HttpMethod::Head => "HEAD",
        HttpMethod::Options => "OPTIONS",
    };

    output.push_str(&format!(r#"
    let req: httpRequest = {{
      method: {},
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: {},
    }}

    switch await Http.request(req) {{
"#, method, body_expr));

    // Parse response
    if let Some(response) = success_response {
        if let Some(ty) = &response.ty {
            if let RsType::Named(type_name) = ty {
                output.push_str(&format!(
                    "    | Ok(json) => switch parse{}(json) {{\n      | Ok(data) => Ok(data)\n      | Error(e) => Error({{status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)}})\n      }}\n",
                    type_name
                ));
            } else {
                output.push_str("    | Ok(json) => Ok(json->Obj.magic)\n");
            }
        } else {
            output.push_str("    | Ok(_) => Ok()\n");
        }
    } else {
        output.push_str("    | Ok(json) => Ok(json->Obj.magic)\n");
    }

    output.push_str("    | Error(e) => Error(e)\n");
    output.push_str("    }\n");
    output.push_str("  }\n");

    output
}

fn build_path(path: &str, path_params: &[&Parameter]) -> String {
    if path_params.is_empty() {
        return format!("\"{}\"", path);
    }

    // Use template literal for path interpolation
    let mut template = path.to_string();

    for param in path_params {
        // Handle {param} style
        let placeholder = format!("{{{}}}", param.name);
        template = template.replace(&placeholder, &format!("${{{}}}", param.name));

        // Handle :param style
        let placeholder_colon = format!(":{}", param.name);
        template = template.replace(&placeholder_colon, &format!("${{{}}}", param.name));
    }

    format!("`{}`", template)
}

fn generate_path_alias(path: &str, method: &HttpMethod) -> String {
    let method_prefix = match method {
        HttpMethod::Get => "get",
        HttpMethod::Post => "create",
        HttpMethod::Put => "update",
        HttpMethod::Patch => "patch",
        HttpMethod::Delete => "delete",
        HttpMethod::Head => "head",
        HttpMethod::Options => "options",
    };

    // /users/{id}/posts -> UsersIdPosts -> getUsersIdPosts
    let path_parts: Vec<_> = path
        .split('/')
        .filter(|s| !s.is_empty() && !s.starts_with('{'))
        .collect();

    let path_name = path_parts
        .iter()
        .map(|s| s.to_pascal_case())
        .collect::<Vec<_>>()
        .join("");

    format!("{}{}", method_prefix, path_name)
}
