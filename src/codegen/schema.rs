// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Hyperpolymath

//! rescript-schema validator generation with topological sorting

use crate::ir::{ApiSpec, TypeDef, Field, RsType};
use super::Config;
use anyhow::Result;
use heck::ToLowerCamelCase;
use std::collections::{HashMap, HashSet, VecDeque};

pub fn generate(spec: &ApiSpec, config: &Config) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str("// SPDX-License-Identifier: AGPL-3.0-or-later\n");
    output.push_str("// Generated by rescript-openapi - DO NOT EDIT\n");
    output.push_str(&format!("// Source: {} v{}\n\n", spec.title, spec.version));

    // Import types
    output.push_str(&format!("open {}Types\n\n", config.module_prefix));

    // Module alias for rescript-schema
    output.push_str("module S = RescriptSchema.S\n\n");

    // Topologically sort types by dependencies
    let sorted_types = topological_sort(&spec.types);

    // Generate schema for each type in dependency order
    for type_def in sorted_types {
        output.push_str(&generate_schema(type_def));
        output.push('\n');
    }

    Ok(output)
}

/// Extract type dependencies from a TypeDef
fn get_dependencies(type_def: &TypeDef) -> HashSet<String> {
    let mut deps = HashSet::new();

    match type_def {
        TypeDef::Record { fields, .. } => {
            for field in fields {
                collect_type_deps(&field.ty, &mut deps);
            }
        }
        TypeDef::Variant { cases, .. } => {
            for case in cases {
                if let Some(ty) = &case.payload {
                    collect_type_deps(ty, &mut deps);
                }
            }
        }
        TypeDef::Alias { target, .. } => {
            collect_type_deps(target, &mut deps);
        }
    }

    deps
}

/// Recursively collect Named type dependencies
fn collect_type_deps(ty: &RsType, deps: &mut HashSet<String>) {
    match ty {
        RsType::Named(name) => {
            deps.insert(name.to_lower_camel_case());
        }
        RsType::Option(inner) | RsType::Array(inner) | RsType::Dict(inner) => {
            collect_type_deps(inner, deps);
        }
        RsType::Tuple(types) => {
            for t in types {
                collect_type_deps(t, deps);
            }
        }
        _ => {}
    }
}

/// Topologically sort types so dependencies come before dependents
pub fn topological_sort(types: &[TypeDef]) -> Vec<&TypeDef> {
    // Build name -> TypeDef map
    let type_map: HashMap<String, &TypeDef> = types
        .iter()
        .map(|t| {
            let name = match t {
                TypeDef::Record { name, .. } => name.to_lower_camel_case(),
                TypeDef::Variant { name, .. } => name.to_lower_camel_case(),
                TypeDef::Alias { name, .. } => name.to_lower_camel_case(),
            };
            (name, t)
        })
        .collect();

    // Build dependency graph (adjacency list: type -> types it depends on)
    let mut deps_map: HashMap<String, HashSet<String>> = HashMap::new();
    let mut all_names: Vec<String> = Vec::new();

    for type_def in types {
        let name = match type_def {
            TypeDef::Record { name, .. } => name.to_lower_camel_case(),
            TypeDef::Variant { name, .. } => name.to_lower_camel_case(),
            TypeDef::Alias { name, .. } => name.to_lower_camel_case(),
        };
        all_names.push(name.clone());

        let deps = get_dependencies(type_def);
        // Only keep deps that are actually in our type set
        let filtered_deps: HashSet<String> = deps
            .into_iter()
            .filter(|d| type_map.contains_key(d))
            .collect();
        deps_map.insert(name, filtered_deps);
    }

    // Kahn's algorithm for topological sort
    // Calculate in-degree (how many types depend on this type)
    let mut in_degree: HashMap<String, usize> = HashMap::new();
    for name in &all_names {
        in_degree.insert(name.clone(), 0);
    }

    // Build reverse graph: for each type, which types depend on it
    for (name, deps) in &deps_map {
        // Each dependency means 'name' has an incoming edge
        // (dep must come before name in the sorted order)
        *in_degree.get_mut(name).unwrap() += deps.len();
    }

    // Start with types that have no dependencies (sorted for deterministic order)
    let mut zero_degree: Vec<String> = in_degree
        .iter()
        .filter(|(_, &degree)| degree == 0)
        .map(|(name, _)| name.clone())
        .collect();
    zero_degree.sort();
    let mut queue: VecDeque<String> = zero_degree.into_iter().collect();

    let mut sorted: Vec<&TypeDef> = Vec::new();

    while let Some(name) = queue.pop_front() {
        if let Some(&type_def) = type_map.get(&name) {
            sorted.push(type_def);
        }

        // For each type that depends on this one, decrease its in-degree
        // Collect newly ready types and sort them for deterministic order
        let mut newly_ready: Vec<String> = Vec::new();
        for (other_name, other_deps) in &deps_map {
            if other_deps.contains(&name) {
                let degree = in_degree.get_mut(other_name).unwrap();
                *degree -= 1;
                if *degree == 0 {
                    newly_ready.push(other_name.clone());
                }
            }
        }
        newly_ready.sort();
        for ready_name in newly_ready {
            queue.push_back(ready_name);
        }
    }

    // If we didn't get all types, there's a cycle - just append remaining
    if sorted.len() < types.len() {
        for type_def in types {
            let name = match type_def {
                TypeDef::Record { name, .. } => name.to_lower_camel_case(),
                TypeDef::Variant { name, .. } => name.to_lower_camel_case(),
                TypeDef::Alias { name, .. } => name.to_lower_camel_case(),
            };
            if !sorted.iter().any(|t| {
                let n = match t {
                    TypeDef::Record { name, .. } => name.to_lower_camel_case(),
                    TypeDef::Variant { name, .. } => name.to_lower_camel_case(),
                    TypeDef::Alias { name, .. } => name.to_lower_camel_case(),
                };
                n == name
            }) {
                sorted.push(type_def);
            }
        }
    }

    sorted
}

fn generate_schema(type_def: &TypeDef) -> String {
    let mut output = String::new();

    match type_def {
        TypeDef::Record { name, doc, fields } => {
            let schema_name = format!("{}Schema", name.to_lower_camel_case());

            if let Some(doc) = doc {
                output.push_str(&format!("/** Schema for {} */\n", doc));
            }

            let type_name = name.to_lower_camel_case();
            output.push_str(&format!("let {}: S.t<{}> = S.object(s => ({{\n", schema_name, type_name));

            for field in fields {
                output.push_str(&generate_field_schema(field));
            }

            output.push_str(&format!("}}: {}))\n", type_name));

            // Add parse helper using parseJsonOrThrow
            output.push('\n');
            output.push_str(&format!(
                "let parse{} = (json: Js.Json.t): {} => {{\n",
                name,
                name.to_lower_camel_case()
            ));
            output.push_str(&format!("  S.parseJsonOrThrow(json, {})\n", schema_name));
            output.push_str("}\n");

            // Add serialize helper using reverseConvertToJsonOrThrow
            output.push('\n');
            output.push_str(&format!(
                "let serialize{} = (value: {}): Js.Json.t => {{\n",
                name,
                name.to_lower_camel_case()
            ));
            output.push_str(&format!("  S.reverseConvertToJsonOrThrow(value, {})\n", schema_name));
            output.push_str("}\n");
        }

        TypeDef::Variant { name, doc, cases } => {
            let schema_name = format!("{}Schema", name.to_lower_camel_case());
            let type_name = name.to_lower_camel_case();

            if let Some(doc) = doc {
                output.push_str(&format!("/** Schema for {} */\n", doc));
            }

            // String enum variant - use S.union with literals
            if cases.iter().all(|c| c.payload.is_none()) {
                output.push_str(&format!("let {}: S.t<{}> = S.union([\n", schema_name, type_name));

                for case in cases {
                    output.push_str(&format!(
                        "  S.literal(#{}),\n",
                        case.name
                    ));
                }

                output.push_str("])\n");
            } else {
                // oneOf/anyOf variant - wrap each referenced type's schema
                output.push_str(&format!("let {}: S.t<{}> = S.union([\n", schema_name, type_name));

                for case in cases {
                    match &case.payload {
                        Some(ty) => {
                            // Wrap the inner schema to transform to variant constructor
                            output.push_str(&format!(
                                "  {}->S.transform(s => {{\n    parser: v => {}(v),\n    serializer: v => switch v {{ | {}(x) => x | _ => S.fail(\"Expected {}\") }}\n  }}),\n",
                                ty.to_schema(),
                                case.name,
                                case.name,
                                case.name
                            ));
                        }
                        None => {
                            // No payload - literal variant
                            output.push_str(&format!(
                                "  S.literal(\"{}\")->S.transform(s => {{\n    parser: _ => #{},\n    serializer: _ => \"{}\"\n  }}),\n",
                                case.name.to_lower_camel_case(),
                                case.name,
                                case.name.to_lower_camel_case()
                            ));
                        }
                    }
                }

                output.push_str("])\n");
            }

            // Add parse/serialize helpers for variants with payloads
            if cases.iter().any(|c| c.payload.is_some()) {
                output.push('\n');
                output.push_str(&format!(
                    "let parse{} = (json: Js.Json.t): {} => {{\n",
                    name,
                    type_name
                ));
                output.push_str(&format!("  S.parseJsonOrThrow(json, {})\n", schema_name));
                output.push_str("}\n");

                output.push('\n');
                output.push_str(&format!(
                    "let serialize{} = (value: {}): Js.Json.t => {{\n",
                    name,
                    type_name
                ));
                output.push_str(&format!("  S.reverseConvertToJsonOrThrow(value, {})\n", schema_name));
                output.push_str("}\n");
            }
        }

        TypeDef::Alias { name, doc, target } => {
            let schema_name = format!("{}Schema", name.to_lower_camel_case());

            if let Some(doc) = doc {
                output.push_str(&format!("/** Schema for {} */\n", doc));
            }

            output.push_str(&format!("let {} = {}\n", schema_name, target.to_schema()));
        }
    }

    output
}

fn generate_field_schema(field: &Field) -> String {
    let method = if field.optional { "fieldOr" } else { "field" };
    let default = if field.optional {
        ", None"
    } else {
        ""
    };

    let schema = field.ty.to_schema();

    if field.name != field.original_name {
        format!(
            "  {}: s.{}(\"{}\", {}{}),\n",
            field.name,
            method,
            field.original_name,
            schema,
            default
        )
    } else {
        format!(
            "  {}: s.{}(\"{}\", {}{}),\n",
            field.name,
            method,
            field.name,
            schema,
            default
        )
    }
}
