// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Hyperpolymath

//! ReScript type generation

use crate::ir::{ApiSpec, TypeDef};
use super::Config;
use super::schema::topological_sort;
use anyhow::Result;
use heck::ToLowerCamelCase;

pub fn generate(spec: &ApiSpec, _config: &Config) -> Result<String> {
    let mut output = String::new();

    // Header
    output.push_str("// SPDX-License-Identifier: AGPL-3.0-or-later\n");
    output.push_str("// Generated by rescript-openapi - DO NOT EDIT\n");
    output.push_str(&format!("// Source: {} v{}\n\n", spec.title, spec.version));

    // Topologically sort types so dependencies come before dependents
    let sorted_types = topological_sort(&spec.types);

    // Generate each type in dependency order
    for type_def in sorted_types {
        output.push_str(&generate_type(type_def));
        output.push('\n');
    }

    Ok(output)
}

fn generate_type(type_def: &TypeDef) -> String {
    let mut output = String::new();

    match type_def {
        TypeDef::Record { name, doc, fields } => {
            if let Some(doc) = doc {
                output.push_str(&format!("/** {} */\n", doc));
            }

            let type_name = name.to_lower_camel_case();
            output.push_str(&format!("type {} = {{\n", type_name));

            for field in fields {
                if let Some(doc) = &field.doc {
                    output.push_str(&format!("  /** {} */\n", doc));
                }

                // Use @as for JSON field mapping if different
                if field.name != field.original_name {
                    output.push_str(&format!("  @as(\"{}\") ", field.original_name));
                } else {
                    output.push_str("  ");
                }

                output.push_str(&format!("{}: {},\n", field.name, field.ty.to_rescript()));
            }

            output.push_str("}\n");
        }

        TypeDef::Variant { name, doc, cases } => {
            if let Some(doc) = doc {
                output.push_str(&format!("/** {} */\n", doc));
            }

            let type_name = name.to_lower_camel_case();
            let has_payloads = cases.iter().any(|c| c.payload.is_some());

            if has_payloads {
                // oneOf/anyOf with payloads - generate regular variant type
                // type pet = Cat(cat) | Dog(dog)
                output.push_str(&format!("type {} =\n", type_name));

                for case in cases {
                    match &case.payload {
                        Some(ty) => {
                            output.push_str(&format!("  | {}({})\n", case.name, ty.to_rescript()));
                        }
                        None => {
                            output.push_str(&format!("  | {}\n", case.name));
                        }
                    }
                }
            } else {
                // String enum - generate as polymorphic variant for better JSON interop
                output.push_str(&format!("type {} = [\n", type_name));

                for case in cases {
                    output.push_str(&format!("  | #{}\n", case.name));
                }

                output.push_str("]\n");

                // Generate string conversion helpers for string enums
                output.push('\n');
                output.push_str(&format!(
                    "let {}ToString = (v: {}) => switch v {{\n",
                    type_name, type_name
                ));
                for case in cases {
                    output.push_str(&format!(
                        "  | #{} => \"{}\"\n",
                        case.name,
                        case.name.to_lower_camel_case()
                    ));
                }
                output.push_str("}\n");

                output.push('\n');
                output.push_str(&format!(
                    "let {}FromString = (s: string): option<{}> => switch s {{\n",
                    type_name, type_name
                ));
                for case in cases {
                    output.push_str(&format!(
                        "  | \"{}\" => Some(#{})\n",
                        case.name.to_lower_camel_case(),
                        case.name
                    ));
                }
                output.push_str("  | _ => None\n");
                output.push_str("}\n");
            }
        }

        TypeDef::Alias { name, doc, target } => {
            if let Some(doc) = doc {
                output.push_str(&format!("/** {} */\n", doc));
            }

            let type_name = name.to_lower_camel_case();
            output.push_str(&format!("type {} = {}\n", type_name, target.to_rescript()));
        }
    }

    output
}
