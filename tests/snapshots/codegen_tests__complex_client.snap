---
source: tests/codegen_tests.rs
expression: client
---
// SPDX-License-Identifier: AGPL-3.0-or-later
// Generated by rescript-openapi - DO NOT EDIT
// Source: Complex API v2.0.0

open RescriptCore
open ApiTypes
open ApiSchema

/** API error type */
type apiError = {
  status: int,
  message: string,
  body: option<Js.Json.t>,
}

/** HTTP method (polymorphic variant for Fetch API) */
type httpMethod = [#GET | #POST | #PUT | #PATCH | #DELETE | #HEAD | #OPTIONS]

/** HTTP request configuration */
type httpRequest = {
  method: httpMethod,
  url: string,
  headers: Dict.t<string>,
  body: option<Js.Json.t>,
}

/** HTTP client module signature - implement this to use any HTTP library */
module type HttpClient = {
  let request: httpRequest => promise<result<Js.Json.t, apiError>>
}

/** Default fetch-based HTTP client using @glennsl/rescript-fetch */
module FetchClient: HttpClient = {
  open Fetch

  let request = async (req: httpRequest): result<Js.Json.t, apiError> => {
    try {
      let init: Request.init = {
        method: (req.method :> Fetch.method),
        headers: Headers.fromObject(req.headers->Obj.magic),
      }
      let init = switch req.body {
      | Some(b) => {...init, body: b->JSON.stringify->Body.string}
      | None => init
      }
      let response = await fetch(req.url, init)

      if response->Response.ok {
        let json = await response->Response.json
        Ok(json)
      } else {
        let status = response->Response.status
        let message = response->Response.statusText
        let body = try {
          Some(await response->Response.json)
        } catch {
        | _ => None
        }
        Error({status, message, body})
      }
    } catch {
    | Exn.Error(e) => Error({
        status: 0,
        message: Exn.message(e)->Option.getOr("Network error"),
        body: None
      })
    }
  }
}

/** Authentication configuration */
type authConfig =
  | NoAuth
  | BearerToken(string)
  | ApiKey({key: string, headerName: string})

/** Client configuration */
type config = {
  baseUrl: string,
  headers: Dict.t<string>,
  auth: authConfig,
}

/** Create client configuration with optional authentication
 *
 * Bearer token auth:
 * ```rescript
 * let config = makeConfig(
 *   ~baseUrl="https://api.example.com",
 *   ~bearerToken="my-jwt-token",
 *   ()
 * )
 * ```
 *
 * API key auth:
 * ```rescript
 * let config = makeConfig(
 *   ~baseUrl="https://api.example.com",
 *   ~apiKey="my-api-key",
 *   ~apiKeyHeader="X-API-Key",
 *   ()
 * )
 * ```
 */
let makeConfig = (
  ~baseUrl: string,
  ~headers=Dict.make(),
  ~bearerToken: option<string>=?,
  ~apiKey: option<string>=?,
  ~apiKeyHeader: string="X-API-Key",
  ()
): config => {
  let auth = switch (bearerToken, apiKey) {
  | (Some(token), _) => BearerToken(token)
  | (_, Some(key)) => ApiKey({key, headerName: apiKeyHeader})
  | (None, None) => NoAuth
  }
  {
    baseUrl,
    headers,
    auth,
  }
}

/** Apply authentication headers to a headers dict */
let applyAuth = (headers: Dict.t<string>, auth: authConfig): unit => {
  switch auth {
  | NoAuth => ()
  | BearerToken(token) => headers->Dict.set("Authorization", `Bearer ${token}`)
  | ApiKey({key, headerName}) => headers->Dict.set(headerName, key)
  }
}

/** Build URL with query parameters */
let buildUrl = (baseUrl: string, path: string, query: Dict.t<string>): string => {
  let url = baseUrl ++ path
  let params = query
    ->Dict.toArray
    ->Array.map(((k, v)) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    ->Array.join("&")

  if params->String.length > 0 {
    url ++ "?" ++ params
  } else {
    url
  }
}

/** API client functor - provide your own HttpClient implementation */
module Make = (Http: HttpClient) => {
  /** List all users */
  let listUsers = async (config: config, ~limit=?, ~offset=?, ~status=?, ()): result<JSON.t, apiError> => {
    let path = "/users"
    let query = Dict.make()
    switch limit { | Some(v) => query->Dict.set("limit", v->String.make) | None => () }
    switch offset { | Some(v) => query->Dict.set("offset", v->String.make) | None => () }
    switch status { | Some(v) => query->Dict.set("status", v->String.make) | None => () }
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Create a new user */
  let createUser = async (config: config, ~body: createUserRequest, ()): result<user, apiError> => {
    let path = "/users"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeCreateUserRequest(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseUser(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Get user by ID */
  let getUser = async (config: config, ~userId: string, ()): result<user, apiError> => {
    let path = `/users/${userId}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseUser(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Send a notification */
  let sendNotification = async (config: config, ~body: notification, ()): result<JSON.t, apiError> => {
    let path = "/notifications"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeNotification(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** List events with polymorphic payloads */
  let listEvents = async (config: config, ()): result<array<event>, apiError> => {
    let path = "/events"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

}

/** Default client using fetch */
module Client = Make(FetchClient)

/** Operation aliases for convenience */
module Aliases = {
  let getUsers = Client.listUsers
  let createUsers = Client.createUser
  let getUsers = Client.getUser
  let createNotifications = Client.sendNotification
  let getEvents = Client.listEvents
}
