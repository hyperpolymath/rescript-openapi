---
source: tests/codegen_tests.rs
expression: schema
---
// SPDX-License-Identifier: AGPL-3.0-or-later
// Generated by rescript-openapi - DO NOT EDIT
// Source: Complex API v2.0.0

open ApiTypes

module S = RescriptSchema.S

let catSchema: S.t<cat> = S.object(s => ({
  name: s.field("name", S.string),
  meowVolume: s.field("meowVolume", S.int),
}: cat))

let parseCat = (json: Js.Json.t): cat => {
  S.parseJsonOrThrow(json, catSchema)
}

let serializeCat = (value: cat): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, catSchema)
}

let dogSchema: S.t<dog> = S.object(s => ({
  name: s.field("name", S.string),
  barkPitch: s.field("barkPitch", S.union([S.literal(#"low"), S.literal(#"medium"), S.literal(#"high")])),
}: dog))

let parseDog = (json: Js.Json.t): dog => {
  S.parseJsonOrThrow(json, dogSchema)
}

let serializeDog = (value: dog): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, dogSchema)
}

let emailNotificationSchema: S.t<emailNotification> = S.object(s => ({
  type_: s.field("type", S.union([S.literal(#"email")])),
  to_: s.field("to", S.string),
  subject: s.field("subject", S.string),
  body: s.field("body", S.string),
  html: s.fieldOr("html", S.option(S.bool), None),
}: emailNotification))

let parseEmailNotification = (json: Js.Json.t): emailNotification => {
  S.parseJsonOrThrow(json, emailNotificationSchema)
}

let serializeEmailNotification = (value: emailNotification): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, emailNotificationSchema)
}

let errorSchema: S.t<error> = S.object(s => ({
  code: s.field("code", S.string),
  message: s.field("message", S.string),
  details: s.fieldOr("details", S.option(S.array(S.json)), None),
}: error))

let parseError = (json: Js.Json.t): error => {
  S.parseJsonOrThrow(json, errorSchema)
}

let serializeError = (value: error): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, errorSchema)
}

let eventSchema: S.t<event> = S.object(s => ({
  id: s.field("id", S.string),
  type_: s.field("type", S.union([S.literal(#"user.created"), S.literal(#"user.updated"), S.literal(#"user.deleted"), S.literal(#"order.placed")])),
  timestamp: s.field("timestamp", S.string),
  payload: s.field("payload", S.json),
}: event))

let parseEvent = (json: Js.Json.t): event => {
  S.parseJsonOrThrow(json, eventSchema)
}

let serializeEvent = (value: event): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, eventSchema)
}

let orderEventPayloadSchema: S.t<orderEventPayload> = S.object(s => ({
  orderId: s.field("orderId", S.string),
  amount: s.field("amount", S.float),
  currency: s.fieldOr("currency", S.option(S.string), None),
}: orderEventPayload))

let parseOrderEventPayload = (json: Js.Json.t): orderEventPayload => {
  S.parseJsonOrThrow(json, orderEventPayloadSchema)
}

let serializeOrderEventPayload = (value: orderEventPayload): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, orderEventPayloadSchema)
}

let paginationMetaSchema: S.t<paginationMeta> = S.object(s => ({
  total: s.field("total", S.int),
  limit: s.field("limit", S.int),
  offset: s.field("offset", S.int),
  hasMore: s.fieldOr("hasMore", S.option(S.bool), None),
}: paginationMeta))

let parsePaginationMeta = (json: Js.Json.t): paginationMeta => {
  S.parseJsonOrThrow(json, paginationMetaSchema)
}

let serializePaginationMeta = (value: paginationMeta): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, paginationMetaSchema)
}

let pushNotificationSchema: S.t<pushNotification> = S.object(s => ({
  type_: s.field("type", S.union([S.literal(#"push")])),
  deviceToken: s.field("deviceToken", S.string),
  title: s.field("title", S.string),
  message: s.field("message", S.string),
  badge: s.fieldOr("badge", S.option(S.int), None),
  sound: s.fieldOr("sound", S.option(S.string), None),
}: pushNotification))

let parsePushNotification = (json: Js.Json.t): pushNotification => {
  S.parseJsonOrThrow(json, pushNotificationSchema)
}

let serializePushNotification = (value: pushNotification): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, pushNotificationSchema)
}

let smsNotificationSchema: S.t<smsNotification> = S.object(s => ({
  type_: s.field("type", S.union([S.literal(#"sms")])),
  phoneNumber: s.field("phoneNumber", S.string),
  message: s.field("message", S.string),
}: smsNotification))

let parseSmsNotification = (json: Js.Json.t): smsNotification => {
  S.parseJsonOrThrow(json, smsNotificationSchema)
}

let serializeSmsNotification = (value: smsNotification): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, smsNotificationSchema)
}

let userEventPayloadSchema: S.t<userEventPayload> = S.object(s => ({
  userId: s.field("userId", S.string),
  changes: s.fieldOr("changes", S.option(S.json), None),
}: userEventPayload))

let parseUserEventPayload = (json: Js.Json.t): userEventPayload => {
  S.parseJsonOrThrow(json, userEventPayloadSchema)
}

let serializeUserEventPayload = (value: userEventPayload): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, userEventPayloadSchema)
}

let userProfileSchema: S.t<userProfile> = S.object(s => ({
  firstName: s.field("firstName", S.string),
  lastName: s.field("lastName", S.string),
  avatar: s.fieldOr("avatar", S.option(S.string), None),
  bio: s.fieldOr("bio", S.option(S.string), None),
  socialLinks: s.fieldOr("socialLinks", S.option(S.json), None),
}: userProfile))

let parseUserProfile = (json: Js.Json.t): userProfile => {
  S.parseJsonOrThrow(json, userProfileSchema)
}

let serializeUserProfile = (value: userProfile): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, userProfileSchema)
}

let userSettingsSchema: S.t<userSettings> = S.object(s => ({
  theme: s.fieldOr("theme", S.option(S.union([S.literal(#"light"), S.literal(#"dark"), S.literal(#"system")])), None),
  language: s.fieldOr("language", S.option(S.string), None),
  notifications: s.fieldOr("notifications", S.option(S.json), None),
}: userSettings))

let parseUserSettings = (json: Js.Json.t): userSettings => {
  S.parseJsonOrThrow(json, userSettingsSchema)
}

let serializeUserSettings = (value: userSettings): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, userSettingsSchema)
}

let petSchema: S.t<pet> = S.union([
  catSchema->S.transform(s => {
    parser: v => Cat(v),
    serializer: v => switch v { | Cat(x) => x | _ => S.fail("Expected Cat") }
  }),
  dogSchema->S.transform(s => {
    parser: v => Dog(v),
    serializer: v => switch v { | Dog(x) => x | _ => S.fail("Expected Dog") }
  }),
])

let parsePet = (json: Js.Json.t): pet => {
  S.parseJsonOrThrow(json, petSchema)
}

let serializePet = (value: pet): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, petSchema)
}

let notificationSchema: S.t<notification> = S.union([
  emailNotificationSchema->S.transform(s => {
    parser: v => EmailNotification(v),
    serializer: v => switch v { | EmailNotification(x) => x | _ => S.fail("Expected EmailNotification") }
  }),
  pushNotificationSchema->S.transform(s => {
    parser: v => PushNotification(v),
    serializer: v => switch v { | PushNotification(x) => x | _ => S.fail("Expected PushNotification") }
  }),
  smsNotificationSchema->S.transform(s => {
    parser: v => SmsNotification(v),
    serializer: v => switch v { | SmsNotification(x) => x | _ => S.fail("Expected SmsNotification") }
  }),
])

let parseNotification = (json: Js.Json.t): notification => {
  S.parseJsonOrThrow(json, notificationSchema)
}

let serializeNotification = (value: notification): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, notificationSchema)
}

let createUserRequestSchema: S.t<createUserRequest> = S.object(s => ({
  email: s.field("email", S.string),
  password: s.field("password", S.string),
  profile: s.field("profile", userProfileSchema),
  settings: s.fieldOr("settings", S.option(userSettingsSchema), None),
}: createUserRequest))

let parseCreateUserRequest = (json: Js.Json.t): createUserRequest => {
  S.parseJsonOrThrow(json, createUserRequestSchema)
}

let serializeCreateUserRequest = (value: createUserRequest): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, createUserRequestSchema)
}

let userSchema: S.t<user> = S.object(s => ({
  id: s.field("id", S.string),
  email: s.field("email", S.string),
  profile: s.field("profile", userProfileSchema),
  settings: s.fieldOr("settings", S.option(userSettingsSchema), None),
  createdAt: s.fieldOr("createdAt", S.option(S.string), None),
  updatedAt: s.fieldOr("updatedAt", S.option(S.string), None),
}: user))

let parseUser = (json: Js.Json.t): user => {
  S.parseJsonOrThrow(json, userSchema)
}

let serializeUser = (value: user): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, userSchema)
}

let searchResultSchema: S.t<searchResult> = S.union([
  userSchema->S.transform(s => {
    parser: v => User(v),
    serializer: v => switch v { | User(x) => x | _ => S.fail("Expected User") }
  }),
  orderEventPayloadSchema->S.transform(s => {
    parser: v => OrderEventPayload(v),
    serializer: v => switch v { | OrderEventPayload(x) => x | _ => S.fail("Expected OrderEventPayload") }
  }),
  S.json->S.transform(s => {
    parser: v => TextMatch(v),
    serializer: v => switch v { | TextMatch(x) => x | _ => S.fail("Expected TextMatch") }
  }),
])

let parseSearchResult = (json: Js.Json.t): searchResult => {
  S.parseJsonOrThrow(json, searchResultSchema)
}

let serializeSearchResult = (value: searchResult): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, searchResultSchema)
}
