---
source: tests/codegen_tests.rs
expression: client
---
// SPDX-License-Identifier: AGPL-3.0-or-later
// Generated by rescript-openapi - DO NOT EDIT
// Source: Swagger Petstore - OpenAPI 3.0 v1.0.27

open RescriptCore
open ApiTypes
open ApiSchema

/** API error type */
type apiError = {
  status: int,
  message: string,
  body: option<Js.Json.t>,
}

/** HTTP method (polymorphic variant for Fetch API) */
type httpMethod = [#GET | #POST | #PUT | #PATCH | #DELETE | #HEAD | #OPTIONS]

/** HTTP request configuration */
type httpRequest = {
  method: httpMethod,
  url: string,
  headers: Dict.t<string>,
  body: option<Js.Json.t>,
}

/** HTTP client module signature - implement this to use any HTTP library */
module type HttpClient = {
  let request: httpRequest => promise<result<Js.Json.t, apiError>>
}

/** Default fetch-based HTTP client using @glennsl/rescript-fetch */
module FetchClient: HttpClient = {
  open Fetch

  let request = async (req: httpRequest): result<Js.Json.t, apiError> => {
    try {
      let init: Request.init = {
        method: (req.method :> Fetch.method),
        headers: Headers.fromObject(req.headers->Obj.magic),
      }
      let init = switch req.body {
      | Some(b) => {...init, body: b->JSON.stringify->Body.string}
      | None => init
      }
      let response = await fetch(req.url, init)

      if response->Response.ok {
        let json = await response->Response.json
        Ok(json)
      } else {
        let status = response->Response.status
        let message = response->Response.statusText
        let body = try {
          Some(await response->Response.json)
        } catch {
        | _ => None
        }
        Error({status, message, body})
      }
    } catch {
    | Exn.Error(e) => Error({
        status: 0,
        message: Exn.message(e)->Option.getOr("Network error"),
        body: None
      })
    }
  }
}

/** Authentication configuration */
type authConfig =
  | NoAuth
  | BearerToken(string)
  | ApiKey({key: string, headerName: string})

/** Client configuration */
type config = {
  baseUrl: string,
  headers: Dict.t<string>,
  auth: authConfig,
}

/** Create client configuration with optional authentication
 *
 * Bearer token auth:
 * ```rescript
 * let config = makeConfig(
 *   ~baseUrl="https://api.example.com",
 *   ~bearerToken="my-jwt-token",
 *   ()
 * )
 * ```
 *
 * API key auth:
 * ```rescript
 * let config = makeConfig(
 *   ~baseUrl="https://api.example.com",
 *   ~apiKey="my-api-key",
 *   ~apiKeyHeader="X-API-Key",
 *   ()
 * )
 * ```
 */
let makeConfig = (
  ~baseUrl: string,
  ~headers=Dict.make(),
  ~bearerToken: option<string>=?,
  ~apiKey: option<string>=?,
  ~apiKeyHeader: string="X-API-Key",
  ()
): config => {
  let auth = switch (bearerToken, apiKey) {
  | (Some(token), _) => BearerToken(token)
  | (_, Some(key)) => ApiKey({key, headerName: apiKeyHeader})
  | (None, None) => NoAuth
  }
  {
    baseUrl,
    headers,
    auth,
  }
}

/** Apply authentication headers to a headers dict */
let applyAuth = (headers: Dict.t<string>, auth: authConfig): unit => {
  switch auth {
  | NoAuth => ()
  | BearerToken(token) => headers->Dict.set("Authorization", `Bearer ${token}`)
  | ApiKey({key, headerName}) => headers->Dict.set(headerName, key)
  }
}

/** Build URL with query parameters */
let buildUrl = (baseUrl: string, path: string, query: Dict.t<string>): string => {
  let url = baseUrl ++ path
  let params = query
    ->Dict.toArray
    ->Array.map(((k, v)) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    ->Array.join("&")

  if params->String.length > 0 {
    url ++ "?" ++ params
  } else {
    url
  }
}

/** API client functor - provide your own HttpClient implementation */
module Make = (Http: HttpClient) => {
  /** Update an existing pet by Id. */
  let updatePet = async (config: config, ~body: pet, ()): result<pet, apiError> => {
    let path = "/pet"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #PUT,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializePet(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parsePet(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Add a new pet to the store. */
  let addPet = async (config: config, ~body: pet, ()): result<pet, apiError> => {
    let path = "/pet"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializePet(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parsePet(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Multiple status values can be provided with comma separated strings. */
  let findPetsByStatus = async (config: config, ~status: [#"available" | #"pending" | #"sold"], ()): result<array<pet>, apiError> => {
    let path = "/pet/findByStatus"
    let query = Dict.make()
    query->Dict.set("status", status->String.make)
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing. */
  let findPetsByTags = async (config: config, ~tags: array<string>, ()): result<array<pet>, apiError> => {
    let path = "/pet/findByTags"
    let query = Dict.make()
    query->Dict.set("tags", tags->String.make)
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Returns a single pet. */
  let getPetById = async (config: config, ~petId: int, ()): result<pet, apiError> => {
    let path = `/pet/${petId->Int.toString}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parsePet(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Updates a pet resource based on the form data. */
  let updatePetWithForm = async (config: config, ~petId: int, ~name=?, ~status=?, ()): result<pet, apiError> => {
    let path = `/pet/${petId->Int.toString}`
    let query = Dict.make()
    switch name { | Some(v) => query->Dict.set("name", v->String.make) | None => () }
    switch status { | Some(v) => query->Dict.set("status", v->String.make) | None => () }
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parsePet(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Delete a pet. */
  let deletePet = async (config: config, ~petId: int, ~apiKey=?, ()): result<unit, apiError> => {
    let path = `/pet/${petId->Int.toString}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)
    switch apiKey { | Some(v) => headers->Dict.set("apiKey", v) | None => () }

    let req: httpRequest = {
      method: #DELETE,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** Upload image of the pet. */
  let uploadFile = async (config: config, ~petId: int, ~additionalMetadata=?, ()): result<apiResponse, apiError> => {
    let path = `/pet/${petId->Int.toString}/uploadImage`
    let query = Dict.make()
    switch additionalMetadata { | Some(v) => query->Dict.set("additionalMetadata", v->String.make) | None => () }
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseApiResponse(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Returns a map of status codes to quantities. */
  let getInventory = async (config: config, ()): result<JSON.t, apiError> => {
    let path = "/store/inventory"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Place a new order in the store. */
  let placeOrder = async (config: config, ~body: order, ()): result<order, apiError> => {
    let path = "/store/order"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeOrder(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseOrder(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions. */
  let getOrderById = async (config: config, ~orderId: int, ()): result<order, apiError> => {
    let path = `/store/order/${orderId->Int.toString}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseOrder(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** For valid response try integer IDs with value < 1000. Anything above 1000 or non-integers will generate API errors. */
  let deleteOrder = async (config: config, ~orderId: int, ()): result<unit, apiError> => {
    let path = `/store/order/${orderId->Int.toString}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #DELETE,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** This can only be done by the logged in user. */
  let createUser = async (config: config, ~body: user, ()): result<user, apiError> => {
    let path = "/user"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeUser(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseUser(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Creates list of users with given input array. */
  let createUsersWithListInput = async (config: config, ~body: array<user>, ()): result<user, apiError> => {
    let path = "/user/createWithList"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(body->Obj.magic),
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseUser(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** Log into the system. */
  let loginUser = async (config: config, ~username=?, ~password=?, ()): result<string, apiError> => {
    let path = "/user/login"
    let query = Dict.make()
    switch username { | Some(v) => query->Dict.set("username", v->String.make) | None => () }
    switch password { | Some(v) => query->Dict.set("password", v->String.make) | None => () }
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Log user out of the system. */
  let logoutUser = async (config: config, ()): result<unit, apiError> => {
    let path = "/user/logout"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** Get user detail based on username. */
  let getUserByName = async (config: config, ~username: string, ()): result<user, apiError> => {
    let path = `/user/${username}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => try {
      Ok(parseUser(json))
    } catch {
    | Exn.Error(e) => Error({status: 0, message: Exn.message(e)->Option.getOr("Parse error"), body: Some(json)})
    }
    | Error(e) => Error(e)
    }
  }

  /** This can only be done by the logged in user. */
  let updateUser = async (config: config, ~username: string, ~body: user, ()): result<unit, apiError> => {
    let path = `/user/${username}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #PUT,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeUser(body)),
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** This can only be done by the logged in user. */
  let deleteUser = async (config: config, ~username: string, ()): result<unit, apiError> => {
    let path = `/user/${username}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    applyAuth(headers, config.auth)

    let req: httpRequest = {
      method: #DELETE,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

}

/** Default client using fetch */
module Client = Make(FetchClient)

/** Operation aliases for convenience */
module Aliases = {
  let createPet = Client.addPet
  let getPetFindByStatus = Client.findPetsByStatus
  let getPetFindByTags = Client.findPetsByTags
  let getPet = Client.getPetById
  let createPet = Client.updatePetWithForm
  let createPetUploadImage = Client.uploadFile
  let getStoreInventory = Client.getInventory
  let createStoreOrder = Client.placeOrder
  let getStoreOrder = Client.getOrderById
  let deleteStoreOrder = Client.deleteOrder
  let createUserCreateWithList = Client.createUsersWithListInput
  let getUserLogin = Client.loginUser
  let getUserLogout = Client.logoutUser
  let getUser = Client.getUserByName
}
