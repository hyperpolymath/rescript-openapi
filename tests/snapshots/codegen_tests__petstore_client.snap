---
source: tests/codegen_tests.rs
expression: client
---
// SPDX-License-Identifier: AGPL-3.0-or-later
// Generated by rescript-openapi - DO NOT EDIT
// Source: Swagger Petstore - OpenAPI 3.0 v1.0.27

open RescriptCore
open ApiTypes
open ApiSchema

/** API error type */
type apiError = {
  status: int,
  message: string,
  body: option<Js.Json.t>,
}

/** HTTP method */
type httpMethod = GET | POST | PUT | PATCH | DELETE | HEAD | OPTIONS

let methodToString = m => switch m {
| GET => "GET"
| POST => "POST"
| PUT => "PUT"
| PATCH => "PATCH"
| DELETE => "DELETE"
| HEAD => "HEAD"
| OPTIONS => "OPTIONS"
}

/** HTTP request configuration */
type httpRequest = {
  method: httpMethod,
  url: string,
  headers: Dict.t<string>,
  body: option<Js.Json.t>,
}

/** HTTP client module signature - implement this to use any HTTP library */
module type HttpClient = {
  let request: httpRequest => promise<result<Js.Json.t, apiError>>
}

/** Default fetch-based HTTP client */
module FetchClient: HttpClient = {
  let request = async (req: httpRequest): promise<result<Js.Json.t, apiError>> => {
    let headers = Fetch.Headers.fromObject(req.headers->Obj.magic)

    let init: Fetch.requestInit = {
      method: req.method->methodToString->Fetch.Method.make,
      headers,
      body: switch req.body {
      | Some(b) => Some(b->Js.Json.stringify->Fetch.Body.string)
      | None => None
      },
    }

    try {
      let response = await Fetch.fetch(req.url, init)

      if response->Fetch.Response.ok {
        let json = await response->Fetch.Response.json
        Ok(json)
      } else {
        let status = response->Fetch.Response.status
        let message = response->Fetch.Response.statusText
        let body = try {
          Some(await response->Fetch.Response.json)
        } catch {
        | _ => None
        }
        Error({status, message, body})
      }
    } catch {
    | Exn.Error(e) => Error({
        status: 0,
        message: Exn.message(e)->Option.getOr("Network error"),
        body: None
      })
    }
  }
}

/** Client configuration */
type config = {
  baseUrl: string,
  headers: Dict.t<string>,
}

let makeConfig = (~baseUrl: string, ~headers=Dict.make(), ()): config => {
  baseUrl,
  headers,
}

/** Build URL with query parameters */
let buildUrl = (baseUrl: string, path: string, query: Dict.t<string>): string => {
  let url = baseUrl ++ path
  let params = query
    ->Dict.toArray
    ->Array.map(((k, v)) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    ->Array.join("&")

  if params->String.length > 0 {
    url ++ "?" ++ params
  } else {
    url
  }
}

/** API client functor - provide your own HttpClient implementation */
module Make = (Http: HttpClient) => {
  /** Update an existing pet by Id. */
  let updatePet = async (config: config, ~body: pet, ()): promise<result<pet, apiError>> => {
    let path = "/pet"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: PUT,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializePet(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => switch parsePet(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** Add a new pet to the store. */
  let addPet = async (config: config, ~body: pet, ()): promise<result<pet, apiError>> => {
    let path = "/pet"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializePet(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => switch parsePet(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** Multiple status values can be provided with comma separated strings. */
  let findPetsByStatus = async (config: config, ~status: [#"available" | #"pending" | #"sold"], ()): promise<result<array<pet>, apiError>> => {
    let path = "/pet/findByStatus"
    let query = Dict.make()
    query->Dict.set("status", status->String.make)
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing. */
  let findPetsByTags = async (config: config, ~tags: array<string>, ()): promise<result<array<pet>, apiError>> => {
    let path = "/pet/findByTags"
    let query = Dict.make()
    query->Dict.set("tags", tags->String.make)
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Returns a single pet. */
  let getPetById = async (config: config, ~petId: int, ()): promise<result<pet, apiError>> => {
    let path = `/pet/${petId}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => switch parsePet(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** Updates a pet resource based on the form data. */
  let updatePetWithForm = async (config: config, ~petId: int, ~name=?, ~status=?, ()): promise<result<pet, apiError>> => {
    let path = `/pet/${petId}`
    let query = Dict.make()
    switch name { | Some(v) => query->Dict.set("name", v->String.make) | None => () }
    switch status { | Some(v) => query->Dict.set("status", v->String.make) | None => () }
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => switch parsePet(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** Delete a pet. */
  let deletePet = async (config: config, ~petId: int, ~apiKey=?, ()): promise<result<unit, apiError>> => {
    let path = `/pet/${petId}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")
    switch apiKey { | Some(v) => headers->Dict.set("apiKey", v) | None => () }

    let req: httpRequest = {
      method: DELETE,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** Upload image of the pet. */
  let uploadFile = async (config: config, ~petId: int, ~additionalMetadata=?, ()): promise<result<apiResponse, apiError>> => {
    let path = `/pet/${petId}/uploadImage`
    let query = Dict.make()
    switch additionalMetadata { | Some(v) => query->Dict.set("additionalMetadata", v->String.make) | None => () }
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => switch parseApiResponse(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** Returns a map of status codes to quantities. */
  let getInventory = async (config: config, ()): promise<result<JSON.t, apiError>> => {
    let path = "/store/inventory"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Place a new order in the store. */
  let placeOrder = async (config: config, ~body: order, ()): promise<result<order, apiError>> => {
    let path = "/store/order"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeOrder(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => switch parseOrder(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions. */
  let getOrderById = async (config: config, ~orderId: int, ()): promise<result<order, apiError>> => {
    let path = `/store/order/${orderId}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => switch parseOrder(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** For valid response try integer IDs with value < 1000. Anything above 1000 or non-integers will generate API errors. */
  let deleteOrder = async (config: config, ~orderId: int, ()): promise<result<unit, apiError>> => {
    let path = `/store/order/${orderId}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: DELETE,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** This can only be done by the logged in user. */
  let createUser = async (config: config, ~body: user, ()): promise<result<user, apiError>> => {
    let path = "/user"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeUser(body)),
    }

    switch await Http.request(req) {
    | Ok(json) => switch parseUser(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** Creates list of users with given input array. */
  let createUsersWithListInput = async (config: config, ~body: array<user>, ()): promise<result<user, apiError>> => {
    let path = "/user/createWithList"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: POST,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(body->Obj.magic),
    }

    switch await Http.request(req) {
    | Ok(json) => switch parseUser(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** Log into the system. */
  let loginUser = async (config: config, ~username=?, ~password=?, ()): promise<result<string, apiError>> => {
    let path = "/user/login"
    let query = Dict.make()
    switch username { | Some(v) => query->Dict.set("username", v->String.make) | None => () }
    switch password { | Some(v) => query->Dict.set("password", v->String.make) | None => () }
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => Ok(json->Obj.magic)
    | Error(e) => Error(e)
    }
  }

  /** Log user out of the system. */
  let logoutUser = async (config: config, ()): promise<result<unit, apiError>> => {
    let path = "/user/logout"
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** Get user detail based on username. */
  let getUserByName = async (config: config, ~username: string, ()): promise<result<user, apiError>> => {
    let path = `/user/${username}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: GET,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(json) => switch parseUser(json) {
      | Ok(data) => Ok(data)
      | Error(e) => Error({status: 0, message: e->RescriptSchema.S.Error.message, body: Some(json)})
      }
    | Error(e) => Error(e)
    }
  }

  /** This can only be done by the logged in user. */
  let updateUser = async (config: config, ~username: string, ~body: user, ()): promise<result<unit, apiError>> => {
    let path = `/user/${username}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: PUT,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: Some(serializeUser(body)),
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

  /** This can only be done by the logged in user. */
  let deleteUser = async (config: config, ~username: string, ()): promise<result<unit, apiError>> => {
    let path = `/user/${username}`
    let query = Dict.make()
    let headers = Dict.fromArray(config.headers->Dict.toArray)
    headers->Dict.set("Content-Type", "application/json")

    let req: httpRequest = {
      method: DELETE,
      url: buildUrl(config.baseUrl, path, query),
      headers,
      body: None,
    }

    switch await Http.request(req) {
    | Ok(_) => Ok()
    | Error(e) => Error(e)
    }
  }

}

/** Default client using fetch */
module Client = Make(FetchClient)

/** Operation aliases for convenience */
module Aliases = {
  let createPet = Client.addPet
  let getPetFindByStatus = Client.findPetsByStatus
  let getPetFindByTags = Client.findPetsByTags
  let getPet = Client.getPetById
  let createPet = Client.updatePetWithForm
  let createPetUploadImage = Client.uploadFile
  let getStoreInventory = Client.getInventory
  let createStoreOrder = Client.placeOrder
  let getStoreOrder = Client.getOrderById
  let deleteStoreOrder = Client.deleteOrder
  let createUserCreateWithList = Client.createUsersWithListInput
  let getUserLogin = Client.loginUser
  let getUserLogout = Client.logoutUser
  let getUser = Client.getUserByName
}
