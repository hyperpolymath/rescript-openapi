---
source: tests/codegen_tests.rs
expression: schema
---
// SPDX-License-Identifier: AGPL-3.0-or-later
// Generated by rescript-openapi - DO NOT EDIT
// Source: Swagger Petstore - OpenAPI 3.0 v1.0.27

open ApiTypes

module S = RescriptSchema.S

let apiResponseSchema: S.t<apiResponse> = S.object(s => ({
  code: s.fieldOr("code", S.option(S.int), None),
  type_: s.fieldOr("type", S.option(S.string), None),
  message: s.fieldOr("message", S.option(S.string), None),
}: apiResponse))

let parseApiResponse = (json: Js.Json.t): apiResponse => {
  S.parseJsonOrThrow(json, apiResponseSchema)
}

let serializeApiResponse = (value: apiResponse): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, apiResponseSchema)
}

let categorySchema: S.t<category> = S.object(s => ({
  id: s.fieldOr("id", S.option(S.int), None),
  name: s.fieldOr("name", S.option(S.string), None),
}: category))

let parseCategory = (json: Js.Json.t): category => {
  S.parseJsonOrThrow(json, categorySchema)
}

let serializeCategory = (value: category): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, categorySchema)
}

let orderSchema: S.t<order> = S.object(s => ({
  id: s.fieldOr("id", S.option(S.int), None),
  petId: s.fieldOr("petId", S.option(S.int), None),
  quantity: s.fieldOr("quantity", S.option(S.int), None),
  shipDate: s.fieldOr("shipDate", S.option(S.string), None),
  status: s.fieldOr("status", S.option(S.union([S.literal(#"placed"), S.literal(#"approved"), S.literal(#"delivered")])), None),
  complete: s.fieldOr("complete", S.option(S.bool), None),
}: order))

let parseOrder = (json: Js.Json.t): order => {
  S.parseJsonOrThrow(json, orderSchema)
}

let serializeOrder = (value: order): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, orderSchema)
}

let tagSchema: S.t<tag> = S.object(s => ({
  id: s.fieldOr("id", S.option(S.int), None),
  name: s.fieldOr("name", S.option(S.string), None),
}: tag))

let parseTag = (json: Js.Json.t): tag => {
  S.parseJsonOrThrow(json, tagSchema)
}

let serializeTag = (value: tag): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, tagSchema)
}

let userSchema: S.t<user> = S.object(s => ({
  id: s.fieldOr("id", S.option(S.int), None),
  username: s.fieldOr("username", S.option(S.string), None),
  firstName: s.fieldOr("firstName", S.option(S.string), None),
  lastName: s.fieldOr("lastName", S.option(S.string), None),
  email: s.fieldOr("email", S.option(S.string), None),
  password: s.fieldOr("password", S.option(S.string), None),
  phone: s.fieldOr("phone", S.option(S.string), None),
  userStatus: s.fieldOr("userStatus", S.option(S.int), None),
}: user))

let parseUser = (json: Js.Json.t): user => {
  S.parseJsonOrThrow(json, userSchema)
}

let serializeUser = (value: user): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, userSchema)
}

let petSchema: S.t<pet> = S.object(s => ({
  id: s.fieldOr("id", S.option(S.int), None),
  name: s.field("name", S.string),
  category: s.fieldOr("category", S.option(categorySchema), None),
  photoUrls: s.field("photoUrls", S.array(S.string)),
  tags: s.fieldOr("tags", S.option(S.array(tagSchema)), None),
  status: s.fieldOr("status", S.option(S.union([S.literal(#"available"), S.literal(#"pending"), S.literal(#"sold")])), None),
}: pet))

let parsePet = (json: Js.Json.t): pet => {
  S.parseJsonOrThrow(json, petSchema)
}

let serializePet = (value: pet): Js.Json.t => {
  S.reverseConvertToJsonOrThrow(value, petSchema)
}
